DoremiScriptParser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "EMPTY_LINE": parse_EMPTY_LINE,
        "HEADER_SECTION": parse_HEADER_SECTION,
        "COMPOSITION": parse_COMPOSITION,
        "ATTRIBUTE_LINE": parse_ATTRIBUTE_LINE,
        "LINE_END": parse_LINE_END,
        "COMPOUND_LINE": parse_COMPOUND_LINE,
        "LINE": parse_LINE,
        "LYRICS_SECTION": parse_LYRICS_SECTION,
        "SIMPLE_LINE": parse_SIMPLE_LINE,
        "SARGAM_ORNAMENT": parse_SARGAM_ORNAMENT,
        "DELIMITED_SARGAM_ORNAMENT": parse_DELIMITED_SARGAM_ORNAMENT,
        "NUMBER_ORNAMENT": parse_NUMBER_ORNAMENT,
        "DELIMITED_NUMBER_ORNAMENT": parse_DELIMITED_NUMBER_ORNAMENT,
        "UPPER_OCTAVE_LINE": parse_UPPER_OCTAVE_LINE,
        "FORWARD_SLASH_CHAR": parse_FORWARD_SLASH_CHAR,
        "CHORD_SYMBOL_CHAR": parse_CHORD_SYMBOL_CHAR,
        "CHORD_SYMBOL_INITIAL_CHAR": parse_CHORD_SYMBOL_INITIAL_CHAR,
        "CHORD_SYMBOL": parse_CHORD_SYMBOL,
        "ALTERNATE_ENDING_INDICATOR": parse_ALTERNATE_ENDING_INDICATOR,
        "UPPER_OCTAVE_LINE_ITEM": parse_UPPER_OCTAVE_LINE_ITEM,
        "LOWER_OCTAVE_LINE": parse_LOWER_OCTAVE_LINE,
        "KOMMAL_INDICATOR": parse_KOMMAL_INDICATOR,
        "LOWER_OCTAVE_LINE_ITEM": parse_LOWER_OCTAVE_LINE_ITEM,
        "LOWER_OCTAVE_DOT": parse_LOWER_OCTAVE_DOT,
        "UPPER_UPPER_OCTAVE_SYMBOL": parse_UPPER_UPPER_OCTAVE_SYMBOL,
        "LOWER_LOWER_OCTAVE_SYMBOL": parse_LOWER_LOWER_OCTAVE_SYMBOL,
        "MORDENT": parse_MORDENT,
        "TALA": parse_TALA,
        "END_SLUR": parse_END_SLUR,
        "BEGIN_SLUR_OF_PITCH": parse_BEGIN_SLUR_OF_PITCH,
        "END_SLUR_OF_PITCH": parse_END_SLUR_OF_PITCH,
        "UPPER_OCTAVE_DOT": parse_UPPER_OCTAVE_DOT,
        "ABC_MEASURE": parse_ABC_MEASURE,
        "NUMBER_MEASURE": parse_NUMBER_MEASURE,
        "DEVANAGRI_MEASURE": parse_DEVANAGRI_MEASURE,
        "MEASURE": parse_MEASURE,
        "ABC_NON_BARLINE": parse_ABC_NON_BARLINE,
        "NUMBER_NON_BARLINE": parse_NUMBER_NON_BARLINE,
        "DEVANAGRI_NON_BARLINE": parse_DEVANAGRI_NON_BARLINE,
        "SARGAM_NON_BARLINE": parse_SARGAM_NON_BARLINE,
        "SARGAM_LINE_ITEM": parse_SARGAM_LINE_ITEM,
        "LINE_NUMBER": parse_LINE_NUMBER,
        "ABC_LINE": parse_ABC_LINE,
        "DEVANAGRI_LINE": parse_DEVANAGRI_LINE,
        "NUMBER_LINE": parse_NUMBER_LINE,
        "SARGAM_LINE": parse_SARGAM_LINE,
        "NUMBER_BEAT_UNDELIMITED": parse_NUMBER_BEAT_UNDELIMITED,
        "ABC_BEAT_UNDELIMITED": parse_ABC_BEAT_UNDELIMITED,
        "BEAT_UNDELIMITED": parse_BEAT_UNDELIMITED,
        "DEVANAGRI_BEAT_UNDELIMITED": parse_DEVANAGRI_BEAT_UNDELIMITED,
        "NUMBER_BEAT_UNDELIMITED_ITEM": parse_NUMBER_BEAT_UNDELIMITED_ITEM,
        "ABC_BEAT_UNDELIMITED_ITEM": parse_ABC_BEAT_UNDELIMITED_ITEM,
        "DEVANAGRI_BEAT_UNDELIMITED_ITEM": parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM,
        "UNDELIMITED_SARGAM_PITCH_WITH_DASHES": parse_UNDELIMITED_SARGAM_PITCH_WITH_DASHES,
        "BEAT_UNDELIMITED_ITEM": parse_BEAT_UNDELIMITED_ITEM,
        "ABC_BEAT_DELIMITED": parse_ABC_BEAT_DELIMITED,
        "NUMBER_BEAT_DELIMITED": parse_NUMBER_BEAT_DELIMITED,
        "DEVANAGRI_BEAT_DELIMITED": parse_DEVANAGRI_BEAT_DELIMITED,
        "BEAT_DELIMITED": parse_BEAT_DELIMITED,
        "BEGIN_BEAT_SYMBOL": parse_BEGIN_BEAT_SYMBOL,
        "END_BEAT_SYMBOL": parse_END_BEAT_SYMBOL,
        "ABC_BEAT_DELIMITED_ITEM": parse_ABC_BEAT_DELIMITED_ITEM,
        "NUMBER_BEAT_DELIMITED_ITEM": parse_NUMBER_BEAT_DELIMITED_ITEM,
        "DEVANAGRI_BEAT_DELIMITED_ITEM": parse_DEVANAGRI_BEAT_DELIMITED_ITEM,
        "BEAT_DELIMITED_ITEM": parse_BEAT_DELIMITED_ITEM,
        "WORD": parse_WORD,
        "_": parse__,
        "SYLLABLE": parse_SYLLABLE,
        "LYRICS_LINE": parse_LYRICS_LINE,
        "RHYTHMICAL_DASH": parse_RHYTHMICAL_DASH,
        "DEVANAGRI_SA": parse_DEVANAGRI_SA,
        "DEVANAGRI_RE": parse_DEVANAGRI_RE,
        "DEVANAGRI_GA": parse_DEVANAGRI_GA,
        "DEVANAGRI_MA_SHARP": parse_DEVANAGRI_MA_SHARP,
        "DEVANAGRI_MA": parse_DEVANAGRI_MA,
        "DEVANAGRI_PA": parse_DEVANAGRI_PA,
        "DEVANAGRI_DHA": parse_DEVANAGRI_DHA,
        "DEVANAGRI_NI": parse_DEVANAGRI_NI,
        "ABC_MUSICAL_CHAR": parse_ABC_MUSICAL_CHAR,
        "ABC_C": parse_ABC_C,
        "ABC_D": parse_ABC_D,
        "ABC_E": parse_ABC_E,
        "ABC_F": parse_ABC_F,
        "ABC_G": parse_ABC_G,
        "ABC_A": parse_ABC_A,
        "ABC_B": parse_ABC_B,
        "ABC_CSHARP": parse_ABC_CSHARP,
        "ABC_CFLAT": parse_ABC_CFLAT,
        "ABC_DFLAT": parse_ABC_DFLAT,
        "ABC_DSHARP": parse_ABC_DSHARP,
        "ABC_EFLAT": parse_ABC_EFLAT,
        "ABC_FSHARP": parse_ABC_FSHARP,
        "ABC_GFLAT": parse_ABC_GFLAT,
        "ABC_GSHARP": parse_ABC_GSHARP,
        "ABC_AFLAT": parse_ABC_AFLAT,
        "ABC_ASHARP": parse_ABC_ASHARP,
        "ABC_BFLAT": parse_ABC_BFLAT,
        "ABC_BSHARP": parse_ABC_BSHARP,
        "NUMBER_MUSICAL_CHAR": parse_NUMBER_MUSICAL_CHAR,
        "NUMBER_C": parse_NUMBER_C,
        "NUMBER_D": parse_NUMBER_D,
        "NUMBER_E": parse_NUMBER_E,
        "NUMBER_F": parse_NUMBER_F,
        "NUMBER_G": parse_NUMBER_G,
        "NUMBER_A": parse_NUMBER_A,
        "NUMBER_B": parse_NUMBER_B,
        "NUMBER_CSHARP": parse_NUMBER_CSHARP,
        "NUMBER_CFLAT": parse_NUMBER_CFLAT,
        "NUMBER_DFLAT": parse_NUMBER_DFLAT,
        "NUMBER_DSHARP": parse_NUMBER_DSHARP,
        "NUMBER_EFLAT": parse_NUMBER_EFLAT,
        "NUMBER_ESHARP": parse_NUMBER_ESHARP,
        "NUMBER_FFLAT": parse_NUMBER_FFLAT,
        "NUMBER_FSHARP": parse_NUMBER_FSHARP,
        "NUMBER_GFLAT": parse_NUMBER_GFLAT,
        "NUMBER_GSHARP": parse_NUMBER_GSHARP,
        "NUMBER_AFLAT": parse_NUMBER_AFLAT,
        "NUMBER_ASHARP": parse_NUMBER_ASHARP,
        "NUMBER_BFLAT": parse_NUMBER_BFLAT,
        "NUMBER_BSHARP": parse_NUMBER_BSHARP,
        "DEVANAGRI_MUSICAL_CHAR": parse_DEVANAGRI_MUSICAL_CHAR,
        "SARGAM_MUSICAL_CHAR": parse_SARGAM_MUSICAL_CHAR,
        "ABC_CHAR": parse_ABC_CHAR,
        "SARGAM_SA": parse_SARGAM_SA,
        "SARGAM_SA_FLAT": parse_SARGAM_SA_FLAT,
        "SARGAM_SA_SHARP": parse_SARGAM_SA_SHARP,
        "SARGAM_RE_FLAT": parse_SARGAM_RE_FLAT,
        "SARGAM_RE": parse_SARGAM_RE,
        "SARGAM_RE_SHARP": parse_SARGAM_RE_SHARP,
        "SARGAM_GA_SHARP": parse_SARGAM_GA_SHARP,
        "SARGAM_GA_FLAT": parse_SARGAM_GA_FLAT,
        "SARGAM_GA": parse_SARGAM_GA,
        "SARGAM_MA": parse_SARGAM_MA,
        "SARGAM_MA_SHARP": parse_SARGAM_MA_SHARP,
        "SARGAM_PA": parse_SARGAM_PA,
        "SARGAM_PA_FLAT": parse_SARGAM_PA_FLAT,
        "SARGAM_PA_SHARP": parse_SARGAM_PA_SHARP,
        "SARGAM_DHA_FLAT": parse_SARGAM_DHA_FLAT,
        "SARGAM_DHA": parse_SARGAM_DHA,
        "SARGAM_DHA_SHARP": parse_SARGAM_DHA_SHARP,
        "SARGAM_NI_FLAT": parse_SARGAM_NI_FLAT,
        "SARGAM_NI": parse_SARGAM_NI,
        "SARGAM_NI_SHARP": parse_SARGAM_NI_SHARP,
        "NUMBER_PITCH": parse_NUMBER_PITCH,
        "ABC_PITCH": parse_ABC_PITCH,
        "DEVANAGRI_PITCH": parse_DEVANAGRI_PITCH,
        "SARGAM_PITCH": parse_SARGAM_PITCH,
        "REPEAT_SYMBOL": parse_REPEAT_SYMBOL,
        "BARLINE": parse_BARLINE,
        "REVERSE_FINAL_BARLINE": parse_REVERSE_FINAL_BARLINE,
        "FINAL_BARLINE": parse_FINAL_BARLINE,
        "DOUBLE_BARLINE": parse_DOUBLE_BARLINE,
        "SINGLE_BARLINE": parse_SINGLE_BARLINE,
        "LEFT_REPEAT": parse_LEFT_REPEAT,
        "RIGHT_REPEAT": parse_RIGHT_REPEAT,
        "LINE_END": parse_LINE_END,
        "LINE_END_CHAR": parse_LINE_END_CHAR,
        "EOL": parse_EOL,
        "EOF": parse_EOF,
        "SPACE": parse_SPACE,
        "WHITE_SPACE": parse_WHITE_SPACE,
        "IGNORED_WHITE_SPACE": parse_IGNORED_WHITE_SPACE
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "COMPOSITION";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_EMPTY_LINE() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = [];
          if (input.charCodeAt(pos) === 32) {
            result1 = " ";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
          while (result1 !== null) {
            result0.push(result1);
            if (input.charCodeAt(pos) === 32) {
              result1 = " ";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\" \"");
              }
            }
          }
          if (result0 !== null) {
            result1 = parse_LINE_END_CHAR();
            if (result1 !== null) {
              result2 = [];
              pos2 = pos;
              result3 = [];
              if (input.charCodeAt(pos) === 32) {
                result4 = " ";
                pos++;
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\" \"");
                }
              }
              while (result4 !== null) {
                result3.push(result4);
                if (input.charCodeAt(pos) === 32) {
                  result4 = " ";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\" \"");
                  }
                }
              }
              if (result3 !== null) {
                result4 = parse_LINE_END_CHAR();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos2;
                }
              } else {
                result3 = null;
                pos = pos2;
              }
              while (result3 !== null) {
                result2.push(result3);
                pos2 = pos;
                result3 = [];
                if (input.charCodeAt(pos) === 32) {
                  result4 = " ";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\" \"");
                  }
                }
                while (result4 !== null) {
                  result3.push(result4);
                  if (input.charCodeAt(pos) === 32) {
                    result4 = " ";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\" \"");
                    }
                  }
                }
                if (result3 !== null) {
                  result4 = parse_LINE_END_CHAR();
                  if (result4 !== null) {
                    result3 = [result3, result4];
                  } else {
                    result3 = null;
                    pos = pos2;
                  }
                } else {
                  result3 = null;
                  pos = pos2;
                }
              }
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset) { return {my_type: "line_end"}
                     })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_HEADER_SECTION() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result1 = parse_ATTRIBUTE_LINE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_ATTRIBUTE_LINE();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result2 = parse_EMPTY_LINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_EMPTY_LINE();
            }
          } else {
            result1 = null;
          }
          if (result1 === null) {
            result1 = parse_EOF();
            if (result1 === null) {
              if (input.substr(pos, 2) === "/n") {
                result1 = "/n";
                pos += 2;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/n\"");
                }
              }
              if (result1 === null) {
                pos2 = pos;
                reportFailures++;
                result1 = parse_LINE();
                reportFailures--;
                if (result1 !== null) {
                  result1 = "";
                  pos = pos2;
                } else {
                  result1 = null;
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, attributes) { return { my_type:"attributes",
                        items: attributes,
                        source: "TODO"
                        }})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Headers followed by blank lines or a line");
        }
        return result0;
      }
      
      function parse_COMPOSITION() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_LINE_END_CHAR();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_LINE_END_CHAR();
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_EMPTY_LINE();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_EMPTY_LINE();
          }
          if (result1 !== null) {
            result2 = parse_HEADER_SECTION();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LINE();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LINE();
              }
              if (result3 !== null) {
                result4 = parse_EOF();
                if (result4 === null) {
                  result4 = parse_EMPTY_LINE();
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, attributes, lines) { 
                  return parse_composition(attributes,lines)
              })(pos0, result0[2], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a musical piece  lines:LINE+ ");
        }
        return result0;
      }
      
      function parse_ATTRIBUTE_LINE() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z_\-0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z_\\-0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z_\-0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z_\\-0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = "";
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 58) {
              result2 = ":";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                if (/^[^\n\r]/.test(input.charAt(pos))) {
                  result5 = input.charAt(pos);
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\n\\r]");
                  }
                }
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    if (/^[^\n\r]/.test(input.charAt(pos))) {
                      result5 = input.charAt(pos);
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^\\n\\r]");
                      }
                    }
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result5 = parse__();
                  if (result5 !== null) {
                    result6 = parse_LINE_END_CHAR();
                    if (result6 === null) {
                      pos2 = pos;
                      reportFailures++;
                      result6 = parse_EOF();
                      reportFailures--;
                      if (result6 !== null) {
                        result6 = "";
                        pos = pos2;
                      } else {
                        result6 = null;
                      }
                    }
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, key_chars, blanks, value_chars) { 
               value=this.trim(value_chars.join(''));
               // true and false get read as boolean ala json
               if (value ==="true") {
                 value=true;
               }
               if (value ==="false") {
                 value=false;
               }
               return { my_type:"attribute",
                        key: key_chars.join(''),
                        value:value,
                        source: "todo"
                        }})(pos0, result0[0], result0[3], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie Author: John Rothfield");
        }
        return result0;
      }
      
      function parse_LINE_END() {
        var result0, result1;
        
        reportFailures++;
        result1 = parse_EMPTY_LINE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_EMPTY_LINE();
          }
        } else {
          result0 = null;
        }
        if (result0 === null) {
          result0 = parse_EOF();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ss");
        }
        return result0;
      }
      
      function parse_COMPOUND_LINE() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_UPPER_OCTAVE_LINE();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_UPPER_OCTAVE_LINE();
        }
        if (result0 !== null) {
          result1 = parse_SARGAM_LINE();
          if (result1 === null) {
            result1 = parse_NUMBER_LINE();
            if (result1 === null) {
              result1 = parse_ABC_LINE();
              if (result1 === null) {
                result1 = parse_DEVANAGRI_LINE();
              }
            }
          }
          if (result1 !== null) {
            result2 = [];
            result3 = parse_LOWER_OCTAVE_LINE();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_LOWER_OCTAVE_LINE();
            }
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LYRICS_LINE();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LYRICS_LINE();
              }
              if (result3 !== null) {
                result4 = parse_LINE_END();
                if (result4 !== null) {
                  result5 = [];
                  result6 = parse_EMPTY_LINE();
                  while (result6 !== null) {
                    result5.push(result6);
                    result6 = parse_EMPTY_LINE();
                  }
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, uppers, sargam, lowers, lyrics) {
                  return parse_line(uppers,sargam,lowers,lyrics)
                })(pos0, result0[0], result0[1], result0[2], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LINE() {
        var result0;
        
        reportFailures++;
        result0 = parse_COMPOUND_LINE();
        if (result0 === null) {
          result0 = parse_SIMPLE_LINE();
          if (result0 === null) {
            result0 = parse_LYRICS_SECTION();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("main line of music. multiple lines including syllables etc,delimited by empty line. There is an order, optional upper octave lines followed by main line of sargam followed by optional lyrics line");
        }
        return result0;
      }
      
      function parse_LYRICS_SECTION() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result1 = parse_LYRICS_LINE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_LYRICS_LINE();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_LINE_END();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_EMPTY_LINE();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_EMPTY_LINE();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, lyrics_lines) { 
                 return parse_lyrics_section(lyrics_lines)
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("AKA verse,chorus,paragraph. Lines of lyrics");
        }
        return result0;
      }
      
      function parse_SIMPLE_LINE() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SARGAM_LINE();
        if (result0 === null) {
          result0 = parse_NUMBER_LINE();
          if (result0 === null) {
            result0 = parse_ABC_LINE();
            if (result0 === null) {
              result0 = parse_DEVANAGRI_LINE();
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_LOWER_OCTAVE_LINE();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_LOWER_OCTAVE_LINE();
          }
          if (result1 !== null) {
            result2 = parse_LYRICS_LINE();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_LINE_END();
              if (result3 !== null) {
                result4 = [];
                result5 = parse_EMPTY_LINE();
                while (result5 !== null) {
                  result4.push(result5);
                  result5 = parse_EMPTY_LINE();
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, sargam, lowers, lyrics) { 
                  uppers=''
                  return parse_line(uppers,sargam,lowers,lyrics)
            })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_ORNAMENT() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_SARGAM_PITCH();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_SARGAM_PITCH();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, items) { 
                    return parse_ornament("",items,"")
                 })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("in upper line NRSNS");
        }
        return result0;
      }
      
      function parse_DELIMITED_SARGAM_ORNAMENT() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 60) {
          result0 = "<";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"<\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_SARGAM_PITCH();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_SARGAM_PITCH();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 62) {
              result2 = ">";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\">\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, left_delimiter, items, right_delimiter) { 
                    return parse_ornament(left_delimiter,items,right_delimiter)
                 })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("in upper line <NRSNS>");
        }
        return result0;
      }
      
      function parse_NUMBER_ORNAMENT() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_NUMBER_PITCH();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NUMBER_PITCH();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, items) { 
                    return parse_ornament("",items,"")
                 })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("in upper line NRSNS");
        }
        return result0;
      }
      
      function parse_DELIMITED_NUMBER_ORNAMENT() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 60) {
          result0 = "<";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"<\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NUMBER_PITCH();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_PITCH();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 62) {
              result2 = ">";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\">\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, left_delimiter, items, right_delimiter) { 
                    return parse_ornament(left_delimiter,items,right_delimiter)
                 })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("in upper line <NRSNS>");
        }
        return result0;
      }
      
      function parse_UPPER_OCTAVE_LINE() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_WHITE_SPACE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_UPPER_OCTAVE_LINE_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_UPPER_OCTAVE_LINE_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_WHITE_SPACE();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_LINE_END();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin_white_space, items, end_white_space) {
                 my_items =  _.compact(_.flatten([begin_white_space, items,end_white_space]))
               return {
                       my_type:"upper_octave_line",
                       source: this.get_source_for_items(my_items),
                       items: my_items
                      } 
              })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("can put upper octave dots or semicolons for upper upper octave (. or :). Also tala symbols +203");
        }
        return result0;
      }
      
      function parse_FORWARD_SLASH_CHAR() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("note that putting forward slash in regex doesn't seem to work");
        }
        return result0;
      }
      
      function parse_CHORD_SYMBOL_CHAR() {
        var result0;
        
        if (/^[a-gA-GmiMaIivV#0-9+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-gA-GmiMaIivV#0-9+]");
          }
        }
        if (result0 === null) {
          result0 = parse_FORWARD_SLASH_CHAR();
        }
        return result0;
      }
      
      function parse_CHORD_SYMBOL_INITIAL_CHAR() {
        var result0;
        
        if (/^[a-gA-GvViI]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-gA-GvViI]");
          }
        }
        return result0;
      }
      
      function parse_CHORD_SYMBOL() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2, pos3;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        pos3 = pos;
        if (/^[SrRgGmMPdDnN]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[SrRgGmMPdDnN]");
          }
        }
        if (result0 !== null) {
          if (/^[SrRgGmMPdDnN]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[SrRgGmMPdDnN]");
            }
          }
          if (result1 !== null) {
            if (/^[SrRgGmMPdDnN]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[SrRgGmMPdDnN]");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos3;
            }
          } else {
            result0 = null;
            pos = pos3;
          }
        } else {
          result0 = null;
          pos = pos3;
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          result1 = parse_CHORD_SYMBOL_INITIAL_CHAR();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_CHORD_SYMBOL_CHAR();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_CHORD_SYMBOL_CHAR();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, initial, chars) {
                      source=initial + chars.join('')
                      return {
                       my_type:"chord_symbol",
                       source: source, 
                      } 
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("I IV V. Put in lookahead for 3 sargam chars. ");
        }
        return result0;
      }
      
      function parse_ALTERNATE_ENDING_INDICATOR() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[1-3]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-3]");
          }
        }
        if (result0 !== null) {
          if (/^[._]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[._]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[._]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[._]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, num, underscores) {
                    if (typeof(dot) == 'undefined') {
                      dot=''
                    }
                    if (typeof(underscores) == 'undefined') {
                      underscores=[]
                    }
                    source=_.flatten([num,dot,underscores]).join('')
                    return {
                      my_type: "ending",
                      source:source,
                      num:parseInt(num)
              }
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("1._______ 2.___ etc. The period is optional. Must have either dot or underscores. TODO: accepts 1_.___ which is not exactly what I want.");
        }
        return result0;
      }
      
      function parse_UPPER_OCTAVE_LINE_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_DELIMITED_SARGAM_ORNAMENT();
        if (result0 === null) {
          result0 = parse_DELIMITED_NUMBER_ORNAMENT();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
            if (result0 === null) {
              result0 = parse_UPPER_OCTAVE_DOT();
              if (result0 === null) {
                result0 = parse_ALTERNATE_ENDING_INDICATOR();
                if (result0 === null) {
                  result0 = parse_TALA();
                  if (result0 === null) {
                    result0 = parse_MORDENT();
                    if (result0 === null) {
                      result0 = parse_UPPER_UPPER_OCTAVE_SYMBOL();
                      if (result0 === null) {
                        result0 = parse_CHORD_SYMBOL();
                        if (result0 === null) {
                          result0 = parse_SARGAM_ORNAMENT();
                          if (result0 === null) {
                            result0 = parse_NUMBER_ORNAMENT();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Things above notes, including talas, octaves,chords, and 1st and second ending symbols");
        }
        return result0;
      }
      
      function parse_LOWER_OCTAVE_LINE() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result1 = parse_LOWER_OCTAVE_LINE_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_LOWER_OCTAVE_LINE_ITEM();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_LINE_END();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, items) {
               my_items =  _.flatten(items)
               if (my_items.length == 0) {
                 return ""
               }
               return {
                       my_type:"lower_octave_line",
                       source: this.get_source_for_items(items),
                       items: my_items
                      } 
              })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("can put lower octave dots or semicolons for lower-lower octave (. or :)");
        }
        return result0;
      }
      
      function parse_KOMMAL_INDICATOR() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 95) {
          result0 = "_";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"_\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "kommal_indicator",
                                source:char,
                                }
                        })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("For the traditional bhatkande notation. for devanagri, indicates a flatted note, since devanagri seems not to have lowercase");
        }
        return result0;
      }
      
      function parse_LOWER_OCTAVE_LINE_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_LOWER_OCTAVE_DOT();
          if (result0 === null) {
            result0 = parse_LOWER_LOWER_OCTAVE_SYMBOL();
            if (result0 === null) {
              result0 = parse_KOMMAL_INDICATOR();
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed(".: for now");
        }
        return result0;
      }
      
      function parse_LOWER_OCTAVE_DOT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[.*]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[.*]");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "lower_octave_indicator",
                                source:char,
                                octave:-1
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_UPPER_UPPER_OCTAVE_SYMBOL() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "upper_upper_octave_indicator",
                                source:char,
                                octave:2
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LOWER_LOWER_OCTAVE_SYMBOL() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "lower_lower_octave_indicator",
                                source:char,
                                octave:-2
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MORDENT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 126) {
          result0 = "~";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"~\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "mordent",
                        source:char
                      }
             })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TALA() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (/^[+1203456]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[+1203456]");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "tala",
                        source:char
             }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("tala markings. ie +203 for tintal. 012 for rupak");
        }
        return result0;
      }
      
      function parse_END_SLUR() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "end_slur",
                                source:char
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol for end of a slur - a right paren");
        }
        return result0;
      }
      
      function parse_BEGIN_SLUR_OF_PITCH() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "begin_slur",
                                source:char
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol for beginning a slur - we use left-paren (");
        }
        return result0;
      }
      
      function parse_END_SLUR_OF_PITCH() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return { my_type: "end_slur",
                                source:char
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol for end of a slur - a right paren");
        }
        return result0;
      }
      
      function parse_UPPER_OCTAVE_DOT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[.*]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[.*]");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { 
                  return { my_type: "upper_octave_indicator",
                                source:char,
                                octave:1
                                }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_MEASURE() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_ABC_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ABC_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, start_obs, items, end_obs) {
        
                  return parse_measure(start_obs,items,end_obs)
                     })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        return result0;
      }
      
      function parse_NUMBER_MEASURE() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_NUMBER_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, start_obs, items, end_obs) {
                  return parse_measure(start_obs,items,end_obs)
                     })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_MEASURE() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_DEVANAGRI_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_DEVANAGRI_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, start_obs, items, end_obs) {
                  return parse_measure(start_obs,items,end_obs)
                     })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        return result0;
      }
      
      function parse_MEASURE() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_SARGAM_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_SARGAM_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, start_obs, items, end_obs) {
                  return parse_measure(start_obs,items,end_obs)
                })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        return result0;
      }
      
      function parse_ABC_NON_BARLINE() {
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_ABC_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_ABC_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_ABC_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  if (result0 !== null) {
                    result0 = (function(offset, x) {
                              x.attributes=[];
                              return x;
                      })(pos0, result0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_NUMBER_NON_BARLINE() {
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_NUMBER_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_NUMBER_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_NUMBER_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  if (result0 !== null) {
                    result0 = (function(offset, x) {
                              x.attributes=[];
                              return x;
                      })(pos0, result0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_DEVANAGRI_NON_BARLINE() {
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_DEVANAGRI_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_DEVANAGRI_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_DEVANAGRI_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  if (result0 !== null) {
                    result0 = (function(offset, x) {
                              x.attributes=[];
                              return x;
                      })(pos0, result0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_SARGAM_NON_BARLINE() {
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_SARGAM_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  if (result0 !== null) {
                    result0 = (function(offset, x) {
                              x.attributes=[];
                              return x;
                      })(pos0, result0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_SARGAM_LINE_ITEM() {
        var result0;
        var pos0;
        
        reportFailures++;
        result0 = parse_MEASURE();
        if (result0 === null) {
          result0 = parse_WHITE_SPACE();
          if (result0 === null) {
            result0 = parse_BEAT_DELIMITED();
            if (result0 === null) {
              result0 = parse_BEAT_UNDELIMITED();
              if (result0 === null) {
                result0 = parse_SARGAM_PITCH();
                if (result0 === null) {
                  result0 = parse_RHYTHMICAL_DASH();
                  if (result0 === null) {
                    result0 = parse_BARLINE();
                    if (result0 === null) {
                      pos0 = pos;
                      result0 = parse_REPEAT_SYMBOL();
                      if (result0 !== null) {
                        result0 = (function(offset, x) {
                                  x.attributes=[];
                                  return x;
                          })(pos0, result0);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("an item in the main line");
        }
        return result0;
      }
      
      function parse_LINE_NUMBER() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[*0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[*0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[*0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[*0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 41) {
            result1 = ")";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits, ch) {
                   source= digits.join('') + ")" 
                  return { my_type: "line_number",
                           source:source,
                         }
                     })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie 1) 2) 3) etc");
        }
        return result0;
      }
      
      function parse_ABC_LINE() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_ABC_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ABC_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, line_number, items) {
               return parse_sargam_line(line_number,items,"ABC")
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_LINE() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_DEVANAGRI_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_DEVANAGRI_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, line_number, items) {
               return parse_sargam_line(line_number,items,"devanagri")
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        return result0;
      }
      
      function parse_NUMBER_LINE() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_NUMBER_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, line_number, items) {
               return parse_sargam_line(line_number,items,"number")
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        return result0;
      }
      
      function parse_SARGAM_LINE() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, line_number, items) {
               return parse_sargam_line(line_number,items,"latin_sargam")
              })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        return result0;
      }
      
      function parse_NUMBER_BEAT_UNDELIMITED() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_NUMBER_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NUMBER_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, beat_items) { 
                    return parse_beat_undelimited(beat_items)
                 })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        return result0;
      }
      
      function parse_ABC_BEAT_UNDELIMITED() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_ABC_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_ABC_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, beat_items) { 
                    return parse_beat_undelimited(beat_items)
                 })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        return result0;
      }
      
      function parse_BEAT_UNDELIMITED() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, beat_items) { 
                    return parse_beat_undelimited(beat_items)
                 })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_UNDELIMITED() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, beat_items) { 
              return parse_beat_undelimited(beat_items)
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        return result0;
      }
      
      function parse_NUMBER_BEAT_UNDELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_NUMBER_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("1--2--3-");
        }
        return result0;
      }
      
      function parse_ABC_BEAT_UNDELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_ABC_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("C--D--E-");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_DEVANAGRI_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a simple beat, ie S--R--G-");
        }
        return result0;
      }
      
      function parse_UNDELIMITED_SARGAM_PITCH_WITH_DASHES() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SARGAM_PITCH();
        if (result0 !== null) {
          result2 = parse_RHYTHMICAL_DASH();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_RHYTHMICAL_DASH();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, pitch, dashes) {
                 pitch.numerator=dashes.length+1
                 return([pitch].concat(dashes))
              })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("for example S--");
        }
        return result0;
      }
      
      function parse_BEAT_UNDELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_UNDELIMITED_SARGAM_PITCH_WITH_DASHES();
        if (result0 === null) {
          result0 = parse_SARGAM_PITCH();
          if (result0 === null) {
            result0 = parse_RHYTHMICAL_DASH();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a simple beat, ie S--R--G- Note that undelimited beats cannot contain spaces");
        }
        return result0;
      }
      
      function parse_ABC_BEAT_DELIMITED() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_ABC_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ABC_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin_symbol, beat_items, end_symbol) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <C D E F> .");
        }
        return result0;
      }
      
      function parse_NUMBER_BEAT_DELIMITED() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_NUMBER_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin_symbol, beat_items, end_symbol) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <1 2 3> . Useful if lyrics wouldn't line up otherwise!. use <Srgm> or <S r g m> to group pithes into a single beat. The <> delimiters correspond to the lower loop in the aacm notation system");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_DELIMITED() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_DEVANAGRI_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_DEVANAGRI_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin_symbol, beat_items, end_symbol) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <S R G m> . Useful if lyrics wouldn't line up otherwise!. use <Srgm> or <S r g m> to group pithes into a single beat. The <> delimiters correspond to the lower loop in the aacm notation system");
        }
        return result0;
      }
      
      function parse_BEAT_DELIMITED() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin_symbol, beat_items, end_symbol) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <S R G m> . Useful if lyrics wouldn't line up otherwise!. use <Srgm> or <S r g m> to group pithes into a single beat. The <> delimiters correspond to the lower loop in the aacm notation system");
        }
        return result0;
      }
      
      function parse_BEGIN_BEAT_SYMBOL() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 60) {
          result0 = "<";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"<\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return {
                                 my_type: "begin_beat",
                                 source: char
                              }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol to use to indicate start of beat");
        }
        return result0;
      }
      
      function parse_END_BEAT_SYMBOL() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 62) {
          result0 = ">";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return {
                                 my_type: "end_beat",
                                 source: char
                              }
                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Symbol to use to indicate end of beat");
        }
        return result0;
      }
      
      function parse_ABC_BEAT_DELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_ABC_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie C--D--E-");
        }
        return result0;
      }
      
      function parse_NUMBER_BEAT_DELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_NUMBER_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie 1--3--2-");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_DELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_DEVANAGRI_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie S--R--G-");
        }
        return result0;
      }
      
      function parse_BEAT_DELIMITED_ITEM() {
        var result0;
        
        reportFailures++;
        result0 = parse_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_IGNORED_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie S--R--G-");
        }
        return result0;
      }
      
      function parse_WORD() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_WHITE_SPACE();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, letters) { return { my_type: "word",
                                                          word: letters.join("")
                                                         }
                                             })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a non-syllable like john");
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result0 = [];
        result1 = parse_SPACE();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_SPACE();
        }
        if (result0 !== null) {
          result0 = (function(offset, blanks) { if (blanks.length==0) {
                                return '' 
                             }
                             return { my_type:"whitespace",
                                     source: blanks.join('')
                                     }
                                     })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse_SYLLABLE() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z'!?\-,]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z'!?\\-,]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z'!?\-,]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z'!?\\-,]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, letters, optional_dash, whitespace) { var syl = letters.join('') + optional_dash
               return _.compact([{ my_type:  "syllable",
                        syllable: syl,
                        source: syl 
                      }, whitespace])
                      })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("for example he- or world");
        }
        return result0;
      }
      
      function parse_LYRICS_LINE() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_WHITE_SPACE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_SYLLABLE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_SYLLABLE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_WHITE_SPACE();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_LINE_END();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin_white_space, items, end_white_space) {  
                 my_items =  _.compact(_.flatten([begin_white_space, items,end_white_space]))
                 return {
                   my_type:"lyrics_line",
                   items:my_items,
                   source: this.get_source_for_items(my_items),
                      }
              })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("line of syllables");
        }
        return result0;
      }
      
      function parse_RHYTHMICAL_DASH() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, source) { 
                         return { my_type: "dash",
                           source: "-"
                              }
                        })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie a -, used as a rhythmical placeholder. IE S--R--G- ");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_SA() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2360) {
          result0 = "\u0938";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0938\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"C")
             })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("sa in devanagri");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_RE() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2352) {
          result0 = "\u0930";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0930\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"D") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("re in devanagri");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_GA() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2394) {
          result0 = "\u095A";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u095A\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"E") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ga in devanagri");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_MA_SHARP() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "\u092E'") {
          result0 = "\u092E'";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u092E'\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"F#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("tivra ma in devanagri. NOTE THE TICK!!!!");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_MA() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2350) {
          result0 = "\u092E";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u092E\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"F") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ma in devanagri");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_PA() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2346) {
          result0 = "\u092A";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u092A\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"G") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("pa in devanagri");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_DHA() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2343) {
          result0 = "\u0927";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0927\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"A") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("dha in devanagri");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_NI() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2345) {
          result0 = "\u0929";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0929\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"B") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ni in devanagri");
        }
        return result0;
      }
      
      function parse_ABC_MUSICAL_CHAR() {
        var result0;
        
        result0 = parse_ABC_CSHARP();
        if (result0 === null) {
          result0 = parse_ABC_CFLAT();
          if (result0 === null) {
            result0 = parse_ABC_DFLAT();
            if (result0 === null) {
              result0 = parse_ABC_DSHARP();
              if (result0 === null) {
                result0 = parse_ABC_EFLAT();
                if (result0 === null) {
                  result0 = parse_ABC_FSHARP();
                  if (result0 === null) {
                    result0 = parse_ABC_GFLAT();
                    if (result0 === null) {
                      result0 = parse_ABC_GSHARP();
                      if (result0 === null) {
                        result0 = parse_ABC_AFLAT();
                        if (result0 === null) {
                          result0 = parse_ABC_ASHARP();
                          if (result0 === null) {
                            result0 = parse_ABC_BFLAT();
                            if (result0 === null) {
                              result0 = parse_ABC_BSHARP();
                              if (result0 === null) {
                                result0 = parse_ABC_C();
                                if (result0 === null) {
                                  result0 = parse_ABC_D();
                                  if (result0 === null) {
                                    result0 = parse_ABC_E();
                                    if (result0 === null) {
                                      result0 = parse_ABC_F();
                                      if (result0 === null) {
                                        result0 = parse_ABC_G();
                                        if (result0 === null) {
                                          result0 = parse_ABC_A();
                                          if (result0 === null) {
                                            result0 = parse_ABC_B();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_ABC_C() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 67) {
          result0 = "C";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"C\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"C") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_D() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 68) {
          result0 = "D";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"D") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_E() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 69) {
          result0 = "E";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"E\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"E") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_F() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 70) {
          result0 = "F";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"F\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"F") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_G() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 71) {
          result0 = "G";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"G") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_A() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 65) {
          result0 = "A";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"A\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"A") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_B() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 66) {
          result0 = "B";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"B\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"B") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_CSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "C#") {
          result0 = "C#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"C#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"C#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_CFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Cb") {
          result0 = "Cb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Cb\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Cb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_DFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Db") {
          result0 = "Db";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Db\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Db") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_DSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "D#") {
          result0 = "D#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"D#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_EFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Eb") {
          result0 = "Eb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Eb\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Eb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_FSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "F#") {
          result0 = "F#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"F#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"F#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_GFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Gb") {
          result0 = "Gb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Gb\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Gb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_GSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "G#") {
          result0 = "G#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"G#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_AFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Ab") {
          result0 = "Ab";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Ab\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Ab") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_ASHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "A#") {
          result0 = "A#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"A#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"A#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_BFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Bb") {
          result0 = "Bb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Bb\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Bb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ABC_BSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "B#") {
          result0 = "B#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"B#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"B#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_MUSICAL_CHAR() {
        var result0;
        
        result0 = parse_NUMBER_CSHARP();
        if (result0 === null) {
          result0 = parse_NUMBER_CFLAT();
          if (result0 === null) {
            result0 = parse_NUMBER_DFLAT();
            if (result0 === null) {
              result0 = parse_NUMBER_DSHARP();
              if (result0 === null) {
                result0 = parse_NUMBER_EFLAT();
                if (result0 === null) {
                  result0 = parse_NUMBER_ESHARP();
                  if (result0 === null) {
                    result0 = parse_NUMBER_FFLAT();
                    if (result0 === null) {
                      result0 = parse_NUMBER_FSHARP();
                      if (result0 === null) {
                        result0 = parse_NUMBER_GFLAT();
                        if (result0 === null) {
                          result0 = parse_NUMBER_GSHARP();
                          if (result0 === null) {
                            result0 = parse_NUMBER_AFLAT();
                            if (result0 === null) {
                              result0 = parse_NUMBER_ASHARP();
                              if (result0 === null) {
                                result0 = parse_NUMBER_BFLAT();
                                if (result0 === null) {
                                  result0 = parse_NUMBER_BSHARP();
                                  if (result0 === null) {
                                    result0 = parse_NUMBER_C();
                                    if (result0 === null) {
                                      result0 = parse_NUMBER_D();
                                      if (result0 === null) {
                                        result0 = parse_NUMBER_E();
                                        if (result0 === null) {
                                          result0 = parse_NUMBER_F();
                                          if (result0 === null) {
                                            result0 = parse_NUMBER_G();
                                            if (result0 === null) {
                                              result0 = parse_NUMBER_A();
                                              if (result0 === null) {
                                                result0 = parse_NUMBER_B();
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_NUMBER_C() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 49) {
          result0 = "1";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"1\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"C") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_D() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 50) {
          result0 = "2";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"2\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"D") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_E() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 51) {
          result0 = "3";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"3\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"E") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_F() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 52) {
          result0 = "4";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"4\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"F") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_G() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 53) {
          result0 = "5";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"5\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"G") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_A() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 54) {
          result0 = "6";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"6\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"A") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_B() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 55) {
          result0 = "7";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"7\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"B") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_CSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "1#") {
          result0 = "1#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"1#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"C#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_CFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "1b") {
          result0 = "1b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"1b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Cb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_DFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "2b") {
          result0 = "2b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"2b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Db") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_DSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "2#") {
          result0 = "2#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"2#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"D#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_EFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "3b") {
          result0 = "3b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"3b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Eb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_ESHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "3#") {
          result0 = "3#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"3#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"E#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_FFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "4b") {
          result0 = "4b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"4b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Fb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_FSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "4#") {
          result0 = "4#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"4#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"F#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_GFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "5b") {
          result0 = "5b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"5b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Gb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_GSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "5#") {
          result0 = "5#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"5#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"G#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_AFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "6b") {
          result0 = "6b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"6b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Ab") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_ASHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "6#") {
          result0 = "6#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"6#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"A#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_BFLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "7b") {
          result0 = "7b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"7b\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"Bb") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_BSHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "7#") {
          result0 = "7#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"7#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) { return sa_helper(char,"B#") })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_DEVANAGRI_MUSICAL_CHAR() {
        var result0;
        
        reportFailures++;
        result0 = parse_DEVANAGRI_SA();
        if (result0 === null) {
          result0 = parse_DEVANAGRI_RE();
          if (result0 === null) {
            result0 = parse_DEVANAGRI_GA();
            if (result0 === null) {
              result0 = parse_DEVANAGRI_MA_SHARP();
              if (result0 === null) {
                result0 = parse_DEVANAGRI_MA();
                if (result0 === null) {
                  result0 = parse_DEVANAGRI_PA();
                  if (result0 === null) {
                    result0 = parse_DEVANAGRI_DHA();
                    if (result0 === null) {
                      result0 = parse_DEVANAGRI_NI();
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("devanagri characters.");
        }
        return result0;
      }
      
      function parse_SARGAM_MUSICAL_CHAR() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        result0 = parse_SARGAM_SA_FLAT();
        if (result0 === null) {
          result0 = parse_SARGAM_SA_SHARP();
          if (result0 === null) {
            result0 = parse_SARGAM_RE_SHARP();
            if (result0 === null) {
              result0 = parse_SARGAM_GA_SHARP();
              if (result0 === null) {
                result0 = parse_SARGAM_PA_SHARP();
                if (result0 === null) {
                  result0 = parse_SARGAM_PA_FLAT();
                  if (result0 === null) {
                    result0 = parse_SARGAM_DHA_SHARP();
                    if (result0 === null) {
                      pos0 = pos;
                      result0 = parse_SARGAM_NI_SHARP();
                      if (result0 !== null) {
                        result1 = parse_SARGAM_PA_FLAT();
                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                      if (result0 === null) {
                        result0 = parse_SARGAM_SA();
                        if (result0 === null) {
                          result0 = parse_SARGAM_RE_FLAT();
                          if (result0 === null) {
                            result0 = parse_SARGAM_RE();
                            if (result0 === null) {
                              result0 = parse_SARGAM_GA_FLAT();
                              if (result0 === null) {
                                result0 = parse_SARGAM_GA();
                                if (result0 === null) {
                                  result0 = parse_SARGAM_MA();
                                  if (result0 === null) {
                                    result0 = parse_SARGAM_MA_SHARP();
                                    if (result0 === null) {
                                      result0 = parse_SARGAM_PA();
                                      if (result0 === null) {
                                        result0 = parse_SARGAM_DHA_FLAT();
                                        if (result0 === null) {
                                          result0 = parse_SARGAM_DHA();
                                          if (result0 === null) {
                                            result0 = parse_SARGAM_NI_FLAT();
                                            if (result0 === null) {
                                              result0 = parse_SARGAM_NI();
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Letters SrRgGmMPdDnN in latin script");
        }
        return result0;
      }
      
      function parse_ABC_CHAR() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (/^[CDEFGAB]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[CDEFGAB]");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {
                 return char;
         })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie SrRgG, and possibly the devanagri characters as well");
        }
        return result0;
      }
      
      function parse_SARGAM_SA() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 83) {
          result0 = "S";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"S\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"C")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_SA_FLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Sb") {
          result0 = "Sb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Sb\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"Cb")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_SA_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "S#") {
          result0 = "S#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"S#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"C#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_RE_FLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 114) {
          result0 = "r";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"r\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"Db")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_RE() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 82) {
          result0 = "R";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"R\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"D")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_RE_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "R#") {
          result0 = "R#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"R#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"D#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_GA_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "G#") {
          result0 = "G#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"E#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_GA_FLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 103) {
          result0 = "g";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"g\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"Eb")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_GA() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 71) {
          result0 = "G";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"E")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_MA() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 109) {
          result0 = "m";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"m\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"F")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_MA_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 77) {
          result0 = "M";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"M\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"F#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_PA() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 80) {
          result0 = "P";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"P\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"G")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_PA_FLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Pb") {
          result0 = "Pb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Pb\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"Gb")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_PA_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "P#") {
          result0 = "P#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"P#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"G#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_DHA_FLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 100) {
          result0 = "d";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"d\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"Ab")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_DHA() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 68) {
          result0 = "D";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"A")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_DHA_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "D#") {
          result0 = "D#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"A#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_NI_FLAT() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 110) {
          result0 = "n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"n\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"Bb")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_NI() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 78) {
          result0 = "N";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"N\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"B")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SARGAM_NI_SHARP() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "N#") {
          result0 = "N#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"N#\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, char) {return sa_helper(char,"B#")})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_NUMBER_PITCH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_NUMBER_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, slur, char, end_slur) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie 123");
        }
        return result0;
      }
      
      function parse_ABC_PITCH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_ABC_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, slur, char, end_slur) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie CDE");
        }
        return result0;
      }
      
      function parse_DEVANAGRI_PITCH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DEVANAGRI_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, slur, char, end_slur) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a sargam pitch ie SrR..");
        }
        return result0;
      }
      
      function parse_SARGAM_PITCH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_SARGAM_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, slur, char, end_slur) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a sargam pitch ie SrR..");
        }
        return result0;
      }
      
      function parse_REPEAT_SYMBOL() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 37) {
          result0 = "%";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"%\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, str) { return { my_type:"repeat_symbol",
                             source: str,
                              }
                      })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie %");
        }
        return result0;
      }
      
      function parse_BARLINE() {
        var result0;
        var pos0;
        
        reportFailures++;
        result0 = parse_REVERSE_FINAL_BARLINE();
        if (result0 === null) {
          result0 = parse_FINAL_BARLINE();
          if (result0 === null) {
            result0 = parse_DOUBLE_BARLINE();
            if (result0 === null) {
              result0 = parse_LEFT_REPEAT();
              if (result0 === null) {
                result0 = parse_RIGHT_REPEAT();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_SINGLE_BARLINE();
                  if (result0 !== null) {
                    result0 = (function(offset, barline) { return barline})(pos0, result0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a musical barline or repeat");
        }
        return result0;
      }
      
      function parse_REVERSE_FINAL_BARLINE() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "[|") {
          result0 = "[|";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[|\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, str) { return { my_type:"reverse_final_barline",
                          source: str,
                         is_barline:true
                        }
                      })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie [|, a reverse final barline");
        }
        return result0;
      }
      
      function parse_FINAL_BARLINE() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "|]") {
          result0 = "|]";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"|]\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, str) { return { my_type:"final_barline",
                            source: str,
                            is_barline:true
                          }
                      })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie ||, a final barline");
        }
        return result0;
      }
      
      function parse_DOUBLE_BARLINE() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "||") {
          result0 = "||";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"||\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, str) { return { my_type:"double_barline",
                             source: str,
                            is_barline:true
                              }
                      })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie ||, a solid barline");
        }
        return result0;
      }
      
      function parse_SINGLE_BARLINE() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 124) {
          result0 = "|";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"|\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, str) { return { my_type: "single_barline",
                           is_barline:true,
                          source: str
                           }
                })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie |");
        }
        return result0;
      }
      
      function parse_LEFT_REPEAT() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "|:") {
          result0 = "|:";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"|:\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return { my_type: "left_repeat",
                           is_barline:true,
                          source: "|:"
                           }
                })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie |:");
        }
        return result0;
      }
      
      function parse_RIGHT_REPEAT() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === ":|") {
          result0 = ":|";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":|\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return { my_type: "right_repeat",
                             is_barline:true,
                             source: ":|"
                           }
                })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie :|");
        }
        return result0;
      }
      
      function parse_LINE_END() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        reportFailures++;
        result0 = parse_EOF();
        reportFailures--;
        if (result0 !== null) {
          result0 = "";
          pos = pos0;
        } else {
          result0 = null;
        }
        if (result0 === null) {
          result0 = parse_EOL();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("eol or eof");
        }
        return result0;
      }
      
      function parse_LINE_END_CHAR() {
        var result0;
        
        if (input.substr(pos, 2) === "\r\n") {
          result0 = "\r\n";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\\n\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 13) {
            result0 = "\r";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 10) {
              result0 = "\n";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\n\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_EOL() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result0 = parse_LINE_END_CHAR();
        if (result0 !== null) {
          result0 = (function(offset) { return { my_type: "end_of_line",
                            source: "\n"
                            }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_EOF() {
        var result0;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return { my_type: "end_of_file",
                          source: "" }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of file");
        }
        return result0;
      }
      
      function parse_SPACE() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("space or tab char");
        }
        return result0;
      }
      
      function parse_WHITE_SPACE() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_SPACE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_SPACE();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, spaces) { return { my_type: "whitespace",
                             source: spaces.join("")
                             }
                             })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("white space");
        }
        return result0;
      }
      
      function parse_IGNORED_WHITE_SPACE() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_SPACE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_SPACE();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, spaces) { return { my_type: "ignored_whitespace",
                             source: spaces.join("")
                             }
                             })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("white space");
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        /* Initializer. All the functions in this block are available */
        debug=false
        if (typeof module !== 'undefined' && module.exports) {
          // running under node.js
          zz = require('./shims.js');
          util = require('util');
          _ = require("underscore")._;
          shared=require('./shared_coffee.js')
          _.extend(root,shared)
          get_composition_attribute=shared.get_composition_attribute
          ParserHelper= require("./parser_helper_coffee.js").ParserHelper
          Fraction=require('./third_party/fraction.js').Fraction
        }
        Helper =ParserHelper
        // Mix in the methods from Helper.
        // TODO: find a more elegant way to do this.
        // didn't work. _.extend(this, Helper) 
        //
        id_ctr=1
        sa_helper=Helper.sa_helper
        push_warning=Helper.push_warning
        parse_line=Helper.parse_line
        handle_ornament=Helper.handle_ornament
        find_ornaments=Helper.find_ornaments
        running_under_node=Helper.running_under_node
        map_ornaments=Helper.map_ornaments
        parse_ornament=Helper.parse_ornament
        parse_composition=Helper.parse_composition
        parse_sargam_pitch=Helper.parse_sargam_pitch
        parse_beat_delimited=Helper.parse_beat_delimited
        parse_beat_undelimited=Helper.parse_beat_undelimited
        parse_measure=Helper.parse_measure
        parse_sargam_line=Helper.parse_sargam_line
        extract_lyrics=Helper.extract_lyrics
        mark_partial_measures= Helper.mark_partial_measures
        measure_dashes_at_beginning_of_beats= Helper.measure_dashes_at_beginning_of_beats
        measure_note_durations= Helper.measure_note_durations
        count_beat_subdivisions = Helper.count_beat_subdivisions
        parens_unbalanced = Helper.parens_unbalanced
        get_source_for_items = Helper.get_source_for_items
        measure_columns = Helper.measure_columns
        assign_attributes=Helper.assign_attributes
        assign_lyrics=Helper.assign_lyrics
        assign_lyrics2=Helper.assign_lyrics2
        collect_nodes = Helper.collect_nodes
        map_nodes = Helper.map_nodes
        check_semantics=Helper.check_semantics
        measure_pitch_durations=Helper.measure_pitch_durations
        parse_lyrics_section=Helper.parse_lyrics_section
        assign_syllables_from_lyrics_sections=Helper.assign_syllables_from_lyrics_sections
        hypher=Helper.hypher
        if (typeof require !== 'undefined') {
          // x=require('./tree_iterators.js')
          all_items=require('./all_items_coffee.js').all_items
        }
        log = Helper.log
        // end of mixin section
        warnings=[]
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
